#!/usr/bin/env python

"""
    YAML2HDF

    @author: Jayghosh S. Rao j.rao@fz-juelich.de

    @description:
        > YAML files are much more user-friendly than HDF5 and JSON files.
        > This tool wraps around CADET-Python to convert between
        > .yaml and .h5 files for use with CADET.

    @usage:
        ## YAML to HDF5
        > yaml2hdf input.yaml -o output.h5                      # Convert input.yaml to output.h5
        > yaml2hdf base.yaml modification.yaml -o output.h5     # Update base.yaml with modification.yaml and write to output.h5
        > yaml2hdf modification.yaml -o output.h5 --update      # Update an existing output.h5 with modification.yaml
        > yaml2hdf input.yaml --print                           # Print input.yaml to stdout

        ## HDF5 to YAML
        > yaml2hdf --reverse input.h5 --print                   # Print input.h5 to stdout
        > yaml2hdf --reverse input.h5 -o output.yaml            # Convert input.h5 to output.yaml

        ## Diff ANY two files
        > yaml2hdf --diff input.h5 new.yaml

        ## Additionally, use with `yq` to extract specific fields out of the yaml/hdf file
        > yaml2hdf --reverse input.h5 --print | yq '.output.solution.unit_001.solution_outlet_comp_000'

    @notes:
        > top level "meta" key is removed before converting both-ways.
        > top level "output" key is removed before writing to h5.

"""

import yaml
import argparse
import numpy as np

from deepdiff import DeepDiff
from pprint import pprint
from pathlib import Path

from cadet import Cadet
from addict import Dict

ap = argparse.ArgumentParser(description='Convert yaml to hdf5')
ap.add_argument("-o", "--output", help="Output hdf5 filename")
ap.add_argument("-r", "--reverse", action='store_true', help="Convert hdf5 to yaml")
ap.add_argument("-u", "--update", action='store_true', help="Update existing h5 file")
ap.add_argument("-p", "--print", action='store_true', help="Print to stdout")
ap.add_argument("-d", "--diff", nargs=2, help="Diff 2 files. Can diff yaml vs h5 as well.")
ap.add_argument("files", nargs='*', help="Input files. Will be applied in order")
args = vars(ap.parse_args())

def reconstruct(dic:dict):
    """
    Convert from addict dict filled with numpy types to
    dict filled with python native types
    """
    cleandict = {}
    for key in dic.keys():
        if isinstance(dic[key], Dict):
            value = reconstruct(dic[key])
            cleandict.update({key: value})
        else:
            value = np2native(dic[key])
            cleandict.update({key: value})
    return cleandict

def update_nested(refdict:dict, newdict:dict):
    for key, value in newdict.items():
        if key in refdict.keys():
            if isinstance(value, dict):
                update_nested(refdict[key], newdict[key])
            else:
                refdict[key] = value
        else:
            refdict.update({key: value})

def np2native(obj):
    """
    Convert from numpy types to python native types
    """
    if isinstance(obj, np.bytes_):
        return obj.tobytes().decode('utf-8')
    elif isinstance(obj, np.generic) or isinstance(obj,np.ndarray):
        return obj.tolist()
    else:
        return obj

def load_h5(fname):
    sim = Cadet()
    sim.filename = fname
    sim.load()
    return(reconstruct(sim.root))


if args['diff']:
    ## Diff ANY two files (even h5 vs yaml)
    ## Only prints changes

    config1 = {}
    config2 = {}

    ext = Path(args['diff'][0]).suffix
    if ext == ".h5":
        config1 = load_h5(args['diff'][0])
    elif ext == ".yaml" or ext == ".yml" :
        with open(args['diff'][0], 'r') as inputfile:
            config1 = yaml.load(inputfile, Loader=yaml.FullLoader)

    ext = Path(args['diff'][1]).suffix
    if ext == ".h5":
        config2 = load_h5(args['diff'][1])
    elif ext == ".yaml" or ext == ".yml" :
        with open(args['diff'][1], 'r') as inputfile:
            config2 = yaml.load(inputfile, Loader=yaml.FullLoader)

    pprint(DeepDiff(config1, config2), indent=2)

elif args['reverse']:
    ## HDF5 to YAML

    ## NOTE: The behavior of this branch should be up for discussion.
    ## Currently when provided with multiple files, generates ONE
    ## final dict/file in line with the way the YAML->HDF flow works

    config = {}
    for fname in args['files']:
        sim = Cadet()
        sim.filename = fname
        sim.load()
        # config = reconstruct(sim.root)                # Only writes/prints the last one
        # config.update(reconstruct(sim.root))          # Non nested update. Always bad
        update_nested(config, reconstruct(sim.root))    # Nested updates of all input h5 files

    try:
        del(config['meta'])
    except KeyError:
        pass

    if args['print']:
        print(yaml.dump(config, allow_unicode=True, default_flow_style=False))

    if args['output']:
        with open(args['output'], 'w') as outfile:
                yaml.dump(config, outfile)

else:
    ## YAML to HDF5
    config = {}
    for fname in args['files']:
        with open(fname, 'r') as inputfile:
            dic = yaml.load(inputfile, Loader=yaml.FullLoader)
            update_nested(config, dic)

    sim = Cadet()

    if args['print']:
        print(yaml.dump(config, allow_unicode=True, default_flow_style=False))

    if args['update'] and args['output']:
        sim.filename = args['output']
        sim.load()
        sim.root.update(Dict(config))

        ## Do not add meta and output info to h5 file
        try:
            del(sim.root['meta'])
            del(sim.root['output'])
        except KeyError:
            pass

        sim.save()

    elif args['output']:
        sim.filename = args['output']
        sim.root = Dict(config)

        ## Do not add meta and output info to h5 file
        try:
            del(sim.root['meta'])
            del(sim.root['output'])
        except KeyError:
            pass

        sim.save()
