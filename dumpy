#!/usr/bin/env python3

"""
@desc:  Tool to handle big endian binary files: split, write to ascii, print to stdout, etc.
@auth:  Jayghosh S. Rao
@usage: ./dumpy <FILES> {-w outfile | -p} {-s <number of splits>} {-v <d | i>} {-z} {-d}
@help: ./dumpy -h
@examples:
    $ dumpy mrng -v i -p -n 4 | vim
    $ dumpy two-spheres.ascii -v f -e '<' -w two-spheres.xyzd -a
    $ dumpy two-spheres.xyzd0 -v f -e '<' -p
    $ dumpy --packing packing.xyzd --nfo packing.nfo -w fixed.xyzd
"""

# TODO: assert array element sizes before writing (int: 4 bytes, float: 4 bytes, double: 8 bytes)
# DONE: in unchunked files, don't append 0 to output filename
# DONE: Handle packing file and particle diameter scaling? Scale every nth value (scale-step?) by sf (scale-factor

# DONE: matplotlib for top view/side view of column?

from __future__ import print_function

import argparse
import struct
import sys
import itertools
import numpy as np
import matplotlib.pyplot as plt

def bin_to_arr(filename, f):
    with(open(filename, 'rb')) as input:
        myiter = struct.iter_unpack(f, input.read())

        arr = []
        for i in myiter:
            arr.append(i[0])

        return arr

        # arr2 = arr[len(arr)//2:]
        # arr2 = arr[0:len(arr)//2]

def arr_to_bin(arr, filename, f):
    with(open(filename, 'wb')) as output:
        for i in arr:
            output.write(struct.pack(f, i))

def arr_to_ascii(arr, filename):
    with(open(filename, 'w')) as output:
        for item in arr:
            output.write(item)

def ascii_to_arr(filename, vartype):
    with(open(filename, 'r')) as inputfile:
        arr = []
        for line in inputfile:
            val = line.strip()
            arr.append(val)
        if(vartype == 'i'):
            arr = [ int(x) for x in arr]
        elif(vartype == 'f'):
            arr = [ np.float32(x) for x in arr]
        elif(vartype == 'd'):
            arr = [ float(x) for x in arr]
        return arr


def print_data(arr, n, vartype):
    if vartype == 'd':
        for chunk in grouper(arr,n):
            print("\t".join("%.6E" % x for x in chunk))
    elif vartype == 'i':
        for chunk in grouper(arr,n):
            print("\t".join("%d" % x for x in chunk))
    elif vartype == 'f':
        for chunk in grouper(arr,n):
            print("\t".join("%.6E" % x for x in chunk))
    # for item in arr:
    #     print(item)

def grouper(iterable, n):
    it = iter(iterable)
    while True:
       chunk = tuple(itertools.islice(it, n))
       if not chunk:
           return
       yield chunk

def scatterPlot(x, y):
    fig, ax = plt.subplots()
    ax.scatter(x, y)
    ax.legend(loc='best', shadow=True)
    ax.set(title='Top View')
    ax.set(xlabel='X')
    ax.set(ylabel='Y')
    ax.autoscale(tight=True)
    fig.savefig('plot.pdf')
    fig.savefig('plot.jpg', dpi=300)
    # plt.show()

def calcFinalScalingFactor(filename):
    data = {}
    with open(filename) as fp:
        for line in fp:
            linesplit = line.strip().split(':')
            data.update({linesplit[0].strip() : linesplit[1].strip().split('(')[0].strip()})
    por_theoretical = float(data['Theoretical Porosity'])
    por_final = float(data['Final Porosity'])

    final_scaling_factor = ( (1-por_final) / (1-por_theoretical) )**(1/3)
    print("Final Scaling Factor:", final_scaling_factor, file=sys.stderr)
    return final_scaling_factor



def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("-p", "--plot", action='store_true', help="Plot X Y as scatter plot")
    ap.add_argument("-a", "--ascii_input", action='store_true', help="input is ascii file")
    ap.add_argument("-v", "--vartype", help="type of variable stored (d | i)", default='d')
    ap.add_argument("-e", "--endianness", help="> or <", default='>')
    ap.add_argument("-n", "--ndf", help="number of items per row", default=1, type=int)
    ap.add_argument("-s", "--split", help="split file into pieces", default = 1, type=int)
    ap.add_argument("-w", "--write", help="write to bin file")
    ap.add_argument("-ss", "--scale-step", help="scale every scale-step'th value by scale-factor", default=1, type=int)
    ap.add_argument("-sf", "--scale-factor", help="scale every scale-step'th value by scale-factor", default=1, type=float)
    ap.add_argument("-z", "--zero-pad", action='store_true', help="Pre-pad file with zeroes")
    ap.add_argument("-d", "--double", action='store_true', help="Double the file. Useful for converting semi-discrete to space-time data.")
    ap.add_argument("--dpacking", action='store_true', help="Input file is packing.xyzd with e=< and n=4 v=d.")
    ap.add_argument("--fpacking", action='store_true', help="Input file is packing.xyzd with e=< and n=4 v=f.")
    ap.add_argument("--nfo", help="Read newly generated packing data and calculate final scaling factor from NFO file.")
    ap.add_argument("FILES", nargs='*', help="files")
    args = vars(ap.parse_args())

    if args['dpacking']:
        args['ndf'] = 4
        args['endianness'] = '<'
        args['plot'] = True
        args['vartype'] = 'd'

    if args['fpacking']:
        args['ndf'] = 4
        args['endianness'] = '<'
        args['plot'] = True
        args['vartype'] = 'f'

    if args['nfo']:
        final_scaling_factor = calcFinalScalingFactor(args['nfo'])
        args['scale_step'] = 4
        args['scale_factor'] = final_scaling_factor

    vartype = args['vartype']
    ndf = args['ndf']
    endianness = args['endianness']
    dataformat = endianness + vartype

    scale_step = args['scale_step']
    scale_factor = args['scale_factor']

    infiles = args['FILES']



    # split = 1
    # if args['split']:
    #     split = args['split']

    print('Note: Default endianness is big (>) to deal with xns files.', file=sys.stderr)

    for infile in infiles:
        # Input
        print("Infile: ", infile, file=sys.stderr)

        if args['ascii_input']:
            array = ascii_to_arr(infile, vartype)
        else:
            array = bin_to_arr(infile, dataformat)

        ## Apply scale_factor to every scale_step'th number
        ## Can scale X, Y, Z, or R/D individually or everything at once
        array[scale_step-1::scale_step] = [x*scale_factor for x in array[scale_step-1::scale_step]]

        # Modify
        zero_array = [ 0 for item in array ]
        if args['zero_pad']:
            array = zero_array + array

        if args['double']:
            array = array + array


        # to split the file into chunks
        out_arrays = []
        out_arrays = np.array_split(np.array(array), args['split'])

        # Output to STDOUT
        for arr in out_arrays:
            print_data(arr, ndf, vartype)

        # Write to BIN output file
        if args['write']:
            if len(out_arrays) > 1:
                for count, arr, in enumerate(out_arrays):
                    writeoutfile = args['write'] + str(count)
                    arr_to_bin(arr, writeoutfile, dataformat)
            else:
                arr_to_bin(arr, args['write'], dataformat)

        if args['plot']:
            for arr in out_arrays:
                x = [ arr[i] for i in range(len(arr)) if i%4 == 0 ]
                y = [ arr[i] for i in range(len(arr)) if i%4 == 1 ]
                scatterPlot(x,y)

if __name__ == "__main__":
    print(__doc__)
    main()
