#!/usr/bin/env python3

"""
@desc:  Tool to handle big endian binary files: split, write to ascii, print to stdout, etc.
@auth:  Jayghosh S. Rao
@usage: ./dumpy <FILES> {-w outfile | -p} {-s <number of splits>} {-v <d | i>} {-z} {-d}
@help: ./dumpy -h
@examples:
    $ dumpy mrng -v i -p -n 4 | vim
    $ dumpy two-spheres.ascii -v f -e '<' -w two-spheres.xyzd -a
    $ dumpy two-spheres.xyzd0 -v f -e '<' -p
"""

# TODO: assert array element sizes before writing (int: 4 bytes, float: 4 bytes, double: 8 bytes)
# TODO: in unchunked files, don't append 0 to output filename

# DONE: matplotlib for top view/side view of column?


import argparse
import struct
import sys
import itertools
import numpy as np
import matplotlib.pyplot as plt

def bin_to_arr(filename, f):
    with(open(filename, 'rb')) as input:
        myiter = struct.iter_unpack(f, input.read())

        arr = []
        for i in myiter:
            arr.append(i[0])

        return arr

        # arr2 = arr[len(arr)//2:]
        # arr2 = arr[0:len(arr)//2]

def arr_to_bin(arr, filename, f):
    with(open(filename, 'wb')) as output:
        for i in arr:
            output.write(struct.pack(f, i))

def arr_to_ascii(arr, filename):
    with(open(filename, 'w')) as output:
        for item in arr:
            output.write(item)

def ascii_to_arr(filename, vartype):
    with(open(filename, 'r')) as inputfile:
        arr = []
        for line in inputfile:
            val = line.strip()
            arr.append(val)
        if(vartype == 'i'):
            arr = [ int(x) for x in arr]
        elif(vartype == 'f'):
            arr = [ np.float32(x) for x in arr]
        elif(vartype == 'd'):
            arr = [ float(x) for x in arr]
        return arr


def print_data(arr, n, vartype):
    if vartype == 'd':
        for chunk in grouper(arr,n):
            print("\t".join("%.6E" % x for x in chunk))
    elif vartype == 'i':
        for chunk in grouper(arr,n):
            print("\t".join("%d" % x for x in chunk))
    elif vartype == 'f':
        for chunk in grouper(arr,n):
            print("\t".join("%.6E" % x for x in chunk))
    # for item in arr:
    #     print(item)

def grouper(iterable, n):
    it = iter(iterable)
    while True:
       chunk = tuple(itertools.islice(it, n))
       if not chunk:
           return
       yield chunk

def scatterPlot(x, y):
    fig, ax = plt.subplots()
    ax.scatter(x, y)
    ax.legend(loc='best', shadow=True)
    ax.set(title='Top View')
    ax.set(xlabel='X')
    ax.set(ylabel='Y')
    ax.autoscale(tight=True)
    fig.savefig('plot.pdf')
    fig.savefig('plot.jpg', dpi=300)
    # plt.show()



def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("-p", "--plot", action='store_true', help="Plot X Y as scatter plot")
    ap.add_argument("-a", "--ascii_input", action='store_true', help="input is ascii file")
    ap.add_argument("-v", "--vartype", help="type of variable stored (d | i)", default='d')
    ap.add_argument("-e", "--endianness", help="> or <", default='>')
    ap.add_argument("-n", "--ndf", help="number of items per row", default=1, type=int)
    ap.add_argument("-s", "--split", help="split file into pieces", default = 1, type=int)
    ap.add_argument("-w", "--write", help="write to bin file")
    ap.add_argument("-z", "--zero-pad", action='store_true', help="Pre-pad file with zeroes")
    ap.add_argument("-d", "--double", action='store_true', help="Double the file. Useful for converting semi-discrete to space-time data.")
    ap.add_argument("FILES", nargs='*', help="files")
    args = vars(ap.parse_args())

    vartype = args['vartype']
    infiles = args['FILES']
    ndf = args['ndf']
    endianness = args['endianness']
    dataformat = endianness + vartype
    split = 1
    if args['split']:
        split = args['split']

    print('Note: Default endianness is big (>) to deal with xns files.')

    for infile in infiles:
        # Input
        print("Infile: ", infile)

        if args['ascii_input']:
            array = ascii_to_arr(infile, vartype)
        else:
            array = bin_to_arr(infile, dataformat)


        # Modify
        zero_array = [ 0 for item in array ]
        if args['zero_pad']:
            array = zero_array + array

        if args['double']:
            array = array + array

        # to split the file into chunks
        out_arrays = []
        out_arrays = np.array_split(np.array(array), split)

        # Output to STDOUT
        for arr in out_arrays:
            print_data(arr, ndf, vartype)

        # Write to BIN output file
        if args['write']:
            count = 0
            for arr in out_arrays:
                arr_to_bin(arr, args['write'] + str(count), dataformat)
                count = count + 1

        if args['plot']:
            for arr in out_arrays:
                x = [ arr[i] for i in range(len(arr)) if i%4 == 0 ]
                y = [ arr[i] for i in range(len(arr)) if i%4 == 1 ]
                scatterPlot(x,y)

if __name__ == "__main__":
    print(__doc__)
    main()
